# TicTacToe.py - Pythonista UI app
# Run this in Pythonista (iPhone/iPad)
#
# Features:
#  - 3x3 touch UI
#  - Local two-player pass-and-play
#  - Single-player vs AI (unbeatable Minimax)
#  - New Game / Undo

import ui
import dialogs
import random
import copy

# -----------------------
# Game logic
# -----------------------
WIN_LINES = [
    (0,1,2),(3,4,5),(6,7,8),  # rows
    (0,3,6),(1,4,7),(2,5,8),  # cols
    (0,4,8),(2,4,6)           # diags
]

def check_winner(board):
    """Return 'X' or 'O' if winner, 'draw' if full and no winner, else None."""
    for a,b,c in WIN_LINES:
        if board[a] and board[a] == board[b] == board[c]:
            return board[a]
    if all(cell != "" for cell in board):
        return "draw"
    return None

def available_moves(board):
    return [i for i,v in enumerate(board) if v == ""]

def minimax(board, player, maximizing):
    """Minimax returns (score, move_index).
       Scores: +1 = X win, -1 = O win, 0 = draw (we assume AI player is 'O' or 'X' depending)"""
    winner = check_winner(board)
    if winner == "X":
        return (1, None)
    elif winner == "O":
        return (-1, None)
    elif winner == "draw":
        return (0, None)

    moves = available_moves(board)
    best_move = None
    if maximizing:
        best_score = -999
        for m in moves:
            board[m] = "X"
            score, _ = minimax(board, "O", False)
            board[m] = ""
            if score > best_score:
                best_score = score
                best_move = m
        return (best_score, best_move)
    else:
        best_score = 999
        for m in moves:
            board[m] = "O"
            score, _ = minimax(board, "X", True)
            board[m] = ""
            if score < best_score:
                best_score = score
                best_move = m
        return (best_score, best_move)

# -----------------------
# UI App
# -----------------------
class TicTacToeApp(ui.View):
    def __init__(self):
        self.name = "Tic-Tac-Toe"
        self.background_color = 'white'
        self.board = [""] * 9
        self.turn = "X"          # 'X' starts
        self.vs_ai = False
        self.ai_player = "O"     # if vs_ai True, AI plays 'O' by default
        self.history = []        # list of (idx, player) for undo

        # Status label
        self.status = ui.Label(frame=(10,10,300,40))
        self.status.font = ('<System>', 18)
        self.status.alignment = ui.ALIGN_CENTER
        self.add_subview(self.status)

        # Buttons: New Game / Undo / Mode
        btn_new = ui.Button(frame=(10,60,98,40), title="New")
        btn_new.action = self.new_game_tapped
        self.add_subview(btn_new)

        btn_undo = ui.Button(frame=(110,60,98,40), title="Undo")
        btn_undo.action = self.undo_tapped
        self.add_subview(btn_undo)

        btn_mode = ui.Button(frame=(210,60,98,40), title="Mode")
        btn_mode.action = self.mode_tapped
        self.add_subview(btn_mode)

        # Board container view
        self.board_view = ui.View(frame=(10,110,300,300))
        self.add_subview(self.board_view)

        # Create 3x3 grid of buttons
        self.buttons = []
        size = 100
        gap = 0
        for i in range(9):
            x = (i % 3) * (size + gap)
            y = (i // 3) * (size + gap)
            b = ui.Button(frame=(x, y, size, size))
            b.title = ""
            b.font = ('<System>', 50)
            b.tint_color = 'black'
            # store index on the button object
            b.idx = i
            b.action = self.cell_tapped
            # style
            b.background_color = 'white'
            b.border_width = 2
            b.border_color = '#222'
            self.board_view.add_subview(b)
            self.buttons.append(b)

        self.present('sheet')
        self.update_ui()

    # -----------------------
    # UI Handlers
    # -----------------------
    def update_ui(self):
        # Update titles
        for i, b in enumerate(self.buttons):
            b.title = self.board[i]
        # Update status
        winner = check_winner(self.board)
        if winner == "X":
            self.status.text = "X wins!"
        elif winner == "O":
            self.status.text = "O wins!"
        elif winner == "draw":
            self.status.text = "Draw!"
        else:
            self.status.text = "{}'s turn".format(self.turn)

    def cell_tapped(self, sender):
        idx = sender.idx
        winner = check_winner(self.board)
        if winner:
            # game over, ignore taps
            dialogs.hud_alert("Game over. Start a new game.", 'info')
            return
        if self.board[idx] != "":
            # already occupied
            return

        # local move
        self.board[idx] = self.turn
        self.history.append((idx, self.turn))
        self.switch_turn()
        self.update_ui()

        # If vs AI and game not finished, let AI play
        if self.vs_ai and check_winner(self.board) is None:
            ui.delay(self.ai_move, 0.2)  # small delay so UI updates nicely

    def switch_turn(self):
        self.turn = "O" if self.turn == "X" else "X"

    def ai_move(self):
        # simple strategy:
        # If AI is 'X' -> maximizing True in minimax
        # If AI is 'O' -> minimizing (we implemented minimax with X maximizing)
        if self.ai_player == "X":
            _, move = minimax(self.board, "X", True)
        else:
            _, move = minimax(self.board, "O", False)
        # If minimax returns None (shouldn't), pick random
        if move is None:
            moves = available_moves(self.board)
            if not moves:
                return
            move = random.choice(moves)

        self.board[move] = self.ai_player
        self.history.append((move, self.ai_player))
        # flip turn back
        self.turn = "O" if self.ai_player == "X" else "X"
        self.update_ui()

    # -----------------------
    # Controls
    # -----------------------
    def new_game_tapped(self, sender):
        choice = dialogs.alert('New Game', 'Choose mode', '2-player', '1-player (vs AI)')
        if choice == 1:
            # 2-player
            self.vs_ai = False
            self.ai_player = None
            self.reset_board()
        else:
            # 1-player: choose whether you want X or O
            pick = dialogs.alert('Play as', 'Choose your mark', 'X (first)', 'O (second)')
            if pick == 1:
                self.vs_ai = True
                self.ai_player = "O"
                self.reset_board()
            else:
                self.vs_ai = True
                self.ai_player = "X"
                self.reset_board()
                # if AI is X it should play first
                ui.delay(self.ai_move, 0.2)

    def undo_tapped(self, sender):
        if not self.history:
            dialogs.hud_alert("Nothing to undo", 'info')
            return
        # Undo last move (or two moves if vs AI to undo both)
        last_idx, last_player = self.history.pop()
        self.board[last_idx] = ""
        if self.vs_ai and self.history and self.history[-1][1] == self.ai_player:
            # also remove AI's previous move if it moved immediately before
            ai_idx, _ = self.history.pop()
            self.board[ai_idx] = ""
        # determine whose turn it is now
        self.turn = "X"
        x_count = self.board.count("X")
        o_count = self.board.count("O")
        if x_count > o_count:
            self.turn = "O"
        elif o_count > x_count:
            self.turn = "X"
        else:
            # if equal, X's turn
            self.turn = "X"
        self.update_ui()

    def mode_tapped(self, sender):
        # toggle quick mode: show current mode and allow switching
        if self.vs_ai:
            if dialogs.confirm("Switch to 2-player?", "This will reset current game."):
                self.vs_ai = False
                self.ai_player = None
                self.reset_board()
        else:
            if dialogs.confirm("Switch to 1-player vs AI?", "This will reset current game."):
                pick = dialogs.alert('Play as', 'Choose your mark', 'X (first)', 'O (second)')
                if pick == 1:
                    self.vs_ai = True
                    self.ai_player = "O"
                    self.reset_board()
                else:
                    self.vs_ai = True
                    self.ai_player = "X"
                    self.reset_board()
                    ui.delay(self.ai_move, 0.2)

    def reset_board(self):
        self.board = [""] * 9
        self.history = []
        self.turn = "X"
        # if AI is X and playing first, let it move
        if self.vs_ai and self.ai_player == "X":
            ui.delay(self.ai_move, 0.2)
        self.update_ui()

# -----------------------
# Run the app
# -----------------------
if __name__ == '__main__':
    TicTacToeApp()